"""Step 5: Measurement instance extraction functionality."""

import logging
from datetime import datetime, timezone
from typing import List, Optional

from pydantic import ValidationError

from agentic_team import RunConfig, RunResult, TResponseInputItem

from ..agents import measurement_instance_extractor_agent
from ..config import (
    MEASUREMENT_INSTANCE_MODEL,
    MEASUREMENT_INSTANCE_OUTPUT_DIR,
    MEASUREMENT_INSTANCE_OUTPUT_FILENAME,
)
from ..schemas import (
    MeasurementInstanceSchema,
    MeasurementTypeSchema,
    SubDomainSchema,
    TopicSchema,
)
from ..utils import direct_save_json_output, run_agent_with_retry

logger = logging.getLogger(__name__)

async def extract_measurement_instances(
    content: str,
    primary_domain: str,
    sub_domain_data: SubDomainSchema,
    topic_data: TopicSchema,
    measurement_type_data: MeasurementTypeSchema,
    overall_trace_id: Optional[str] = None,
) -> Optional[MeasurementInstanceSchema]:
    """Extract measurement instances based on previously identified types."""

    if not (primary_domain and sub_domain_data and topic_data and measurement_type_data):
        logger.info("Skipping measurement instance extraction due to missing prerequisites.")
        return None

    logger.info(
        f"--- Running Step 5: Measurement Instance Extraction (Agent: {measurement_instance_extractor_agent.name}) ---"
    )
    print(f"\n--- Running Step 5: Measurement Instance Extraction using model: {MEASUREMENT_INSTANCE_MODEL} ---")

    step5_metadata = {
        "workflow_step": "5_measurement_instance_extraction",
        "agent_name": measurement_instance_extractor_agent.name,
        "primary_domain_input": primary_domain,
        "measurement_type_count": str(len(measurement_type_data.identified_measurements)),
    }
    step5_run_config = RunConfig(trace_metadata={k: str(v) for k, v in step5_metadata.items()})

    context_summary = (
        f"Primary Domain: {primary_domain}\n"
        f"Sub-Domains: {', '.join(sd.sub_domain for sd in sub_domain_data.identified_sub_domains)}\n"
        f"Measurement Types Identified: {', '.join(mt.measurement_type for mt in measurement_type_data.identified_measurements)}"
    )

    step5_input: List[TResponseInputItem] = [
        {
            "role": "user",
            "content": (
                "Extract any measurement values or indicators mentioned in the text. "
                "Use the context provided to stay focused on relevant measurements. "
                "Output ONLY using the MeasurementInstanceSchema.\n"
                f"Context:\n{context_summary}"
            ),
        },
        {"role": "user", "content": f"--- Full Text Start ---\n{content}\n--- Full Text End ---"},
    ]

    try:
        result: RunResult = await run_agent_with_retry(
            agent=measurement_instance_extractor_agent,
            input_data=step5_input,
            config=step5_run_config,
        )

        potential_output = getattr(result, "final_output", None)
        data: Optional[MeasurementInstanceSchema] = None

        if isinstance(potential_output, MeasurementInstanceSchema):
            data = potential_output
        elif isinstance(potential_output, dict):
            try:
                data = MeasurementInstanceSchema.model_validate(potential_output)
            except ValidationError as e:
                logger.warning(f"Measurement instance output failed validation: {e}")
        else:
            logger.warning(
                f"Measurement instance extractor returned unexpected type: {type(potential_output)}"
            )

        if data and data.measurement_instances:
            output_content = {
                "primary_domain": data.primary_domain,
                "analyzed_sub_domains": data.analyzed_sub_domains,
                "measurement_instances": [item.model_dump() for item in data.measurement_instances],
                "analysis_summary": data.analysis_summary,
                "analysis_details": {
                    "source_text_length": len(content),
                    "model_used": MEASUREMENT_INSTANCE_MODEL,
                    "agent_name": measurement_instance_extractor_agent.name,
                    "timestamp_utc": datetime.now(timezone.utc).isoformat(),
                },
                "trace_information": {
                    "trace_id": overall_trace_id or "N/A",
                    "notes": f"Generated by {measurement_instance_extractor_agent.name} in Step 5",
                },
            }
            save_result = direct_save_json_output(
                MEASUREMENT_INSTANCE_OUTPUT_DIR,
                MEASUREMENT_INSTANCE_OUTPUT_FILENAME,
                output_content,
                overall_trace_id,
            )
            print(f"  - {save_result}")
            logger.info(f"Result of saving measurement instance output: {save_result}")
        elif data:
            logger.warning("Measurement instance extraction succeeded but no instances found.")
        else:
            logger.error("Failed to extract valid MeasurementInstanceSchema output.")
            return None

        return data

    except (ValidationError, TypeError) as e:
        logger.exception("Validation or Type error during measurement instance extraction.")
        print(f"Error during measurement instance extraction: {e}")
        return None
    except Exception as e:
        logger.exception("Unexpected error during measurement instance extraction.")
        print(f"Unexpected error during measurement instance extraction: {e}")
        return None
