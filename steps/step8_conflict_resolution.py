"""Step 8: Conflict resolution functionality."""

import json
import logging
from datetime import datetime, timezone
from typing import Any, List, Optional

from pydantic import ValidationError

from agentic_team import RunConfig, RunResult, TResponseInputItem

from ..agents import conflict_resolution_agent
from ..config import (
    CONFLICT_RESOLUTION_MODEL,
    CONFLICT_RESOLUTION_OUTPUT_DIR,
    CONFLICT_RESOLUTION_OUTPUT_FILENAME,
)
from ..schemas import ResolvedTripletSchema
from ..utils import direct_save_json_output, run_agent_with_retry

logger = logging.getLogger(__name__)


async def resolve_conflicts(
    aligned_candidates: Any,
    overall_trace_id: Optional[str] = None,
) -> Optional[ResolvedTripletSchema]:
    """Resolve conflicts between aligned candidate triplets and existing facts."""
    if not aligned_candidates:
        logger.info("Skipping Step 8 because no aligned candidate data was provided.")
        print("Skipping Step 8 as no aligned candidate data was available.")
        return None

    logger.info(
        f"--- Running Step 8: Conflict Resolution (Agent: {conflict_resolution_agent.name}) ---"
    )
    print(f"\n--- Running Step 8: Conflict Resolution using model: {CONFLICT_RESOLUTION_MODEL} ---")

    step8_metadata = {
        "workflow_step": "8_conflict_resolution",
        "agent_name": "Conflict Resolution",
        "actual_agent": str(conflict_resolution_agent.name),
    }
    step8_run_config = RunConfig(trace_metadata={k: str(v) for k, v in step8_metadata.items()})

    aligned_json = json.dumps(aligned_candidates, ensure_ascii=False, indent=2)
    step8_input: List[TResponseInputItem] = [
        {
            "role": "user",
            "content": (
                "Resolve potential conflicts between these schema-aligned candidate triplets "
                "and the existing knowledge graph. For each candidate, decide whether it "
                "should be added, update an existing fact, or be ignored. "
                f"Return the result using {ResolvedTripletSchema.__name__}."
            ),
        },
        {
            "role": "user",
            "content": f"--- Aligned Candidates Start ---\n{aligned_json}\n--- Aligned Candidates End ---",
        },
    ]

    try:
        step8_result: RunResult = await run_agent_with_retry(
            agent=conflict_resolution_agent,
            input_data=step8_input,
            config=step8_run_config,
        )

        resolved_data: Optional[ResolvedTripletSchema] = None
        if step8_result:
            potential_output = getattr(step8_result, "final_output", None)
            if isinstance(potential_output, ResolvedTripletSchema):
                resolved_data = potential_output
            elif isinstance(potential_output, dict):
                try:
                    resolved_data = ResolvedTripletSchema.model_validate(potential_output)
                except ValidationError as e:
                    logger.warning(
                        f"Step 8 output dict failed ResolvedTripletSchema validation: {e}"
                    )
            else:
                logger.warning(
                    f"Step 8 final_output unexpected type: {type(potential_output)}"
                )

        if resolved_data:
            logger.info("Saving conflict resolution output to file...")
            print("\nSaving conflict resolution output file...")
            output_content = {
                "resolved_triplets": [t.model_dump() for t in resolved_data.resolved_triplets],
                "summary": resolved_data.summary,
                "analysis_details": {
                    "candidate_count": len(aligned_candidates)
                    if hasattr(aligned_candidates, "__len__")
                    else "unknown",
                    "model_used": CONFLICT_RESOLUTION_MODEL,
                    "agent_name": conflict_resolution_agent.name,
                    "output_schema": ResolvedTripletSchema.__name__,
                    "timestamp_utc": datetime.now(timezone.utc).isoformat(),
                },
                "trace_information": {
                    "trace_id": overall_trace_id or "N/A",
                    "notes": f"Generated by {conflict_resolution_agent.name} in Step 8.",
                },
            }
            save_msg = direct_save_json_output(
                CONFLICT_RESOLUTION_OUTPUT_DIR,
                CONFLICT_RESOLUTION_OUTPUT_FILENAME,
                output_content,
                overall_trace_id,
            )
            print(f"  - {save_msg}")
            logger.info(f"Result of saving conflict resolution output: {save_msg}")
        else:
            print("\nStep 8 produced no resolved triplets.")

        return resolved_data

    except Exception as e:  # pylint: disable=broad-except
        logger.exception("Step 8 failed with an unexpected error.", exc_info=e)
        print(f"Error during conflict resolution: {type(e).__name__}: {e}")
        return None
